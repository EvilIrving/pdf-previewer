<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Viewer</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Vue 3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {}
            }
        }
    </script>
    <style>
        [v-cloak] {
            display: none;
        }

        .tree-item {
            transition: background-color 0.15s ease;
        }
    </style>
</head>

<body>
    <div id="app" v-cloak>
        <div :class="{ 'dark': isDark }" class="h-screen">
            <div class="flex h-full bg-slate-50 dark:bg-slate-900 text-slate-800 dark:text-slate-200">
                <!-- Sidebar -->
                <aside :class="sidebarCollapsed ? 'w-0 overflow-hidden' : 'w-64'"
                    class="flex-shrink-0 bg-slate-100 dark:bg-slate-800 border-r border-slate-200 dark:border-slate-700 flex flex-col transition-all duration-300">
                    <!-- Sidebar Header -->
                    <div class="p-3 border-b border-slate-200 dark:border-slate-700">
                        <div class="flex items-center justify-between mb-3">
                            <span class="font-semibold text-sm">PDF Viewer</span>
                            <button @click="isDark = !isDark"
                                class="p-1.5 rounded hover:bg-slate-200 dark:hover:bg-slate-700"
                                :title="isDark ? '切换浅色模式' : '切换深色模式'">
                                <svg v-if="isDark" class="w-4 h-4" fill="none" stroke="currentColor"
                                    viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
                                </svg>
                                <svg v-else class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
                                </svg>
                            </button>
                        </div>
                        <div class="space-y-2">
                            <label
                                class="flex items-center justify-center gap-2 px-3 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded cursor-pointer transition-colors">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
                                </svg>
                                <span>选择文件夹</span>
                                <span class="text-xs opacity-75" id="folder-shortcut">(Ctrl+O)</span>
                                <input type="file" webkitdirectory directory multiple @change="handleFolderSelect"
                                    class="hidden">
                            </label>
                            <label
                                class="flex items-center justify-center gap-2 px-3 py-2 bg-slate-500 hover:bg-slate-600 text-white rounded cursor-pointer transition-colors">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                                </svg>
                                <span>选择文件</span>
                                <span class="text-xs opacity-75" id="file-shortcut">(Ctrl+Shift+O)</span>
                                <input type="file" accept=".pdf" multiple @change="handleFileSelect"
                                    class="hidden">
                            </label>
                        </div>
                    </div>

                    <!-- File Tree -->
                    <div class="flex-1 overflow-y-auto scrollbar-thin p-2">
                        <template v-if="fileTree.length > 0">
                            <tree-item v-for="item in fileTree" :key="item.path" :item="item"
                                :selected-path="selectedFile?.path" :depth="0" @select="selectFile" />
                        </template>
                        <div v-else class="text-center text-slate-400 dark:text-slate-500 py-8">
                            <p>暂无文件</p>
                            <p class="text-xs mt-1">请选择包含 PDF 的文件夹</p>
                        </div>
                    </div>

                    <!-- Sidebar Footer -->
                    <div v-if="pdfFiles.length > 0"
                        class="p-3 border-t border-slate-200 dark:border-slate-700 text-xs text-slate-500 dark:text-slate-400">
                        共 {{ pdfFiles.length }} 个 PDF 文件
                    </div>
                </aside>

                <!-- Main Content -->
                <main class="flex-1 flex flex-col min-w-0 h-full">
                    <!-- Toggle Sidebar Button (when collapsed) -->
                    <button v-if="sidebarCollapsed" @click="sidebarCollapsed = false"
                        class="absolute top-3 left-3 z-10 p-2 bg-slate-100 dark:bg-slate-800 rounded hover:bg-slate-200 dark:hover:bg-slate-700">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M13 5l7 7-7 7M5 5l7 7-7 7" />
                        </svg>
                    </button>

                    <!-- Toolbar -->
                    <div v-if="selectedFile"
                        class="flex items-center justify-between px-4 py-2 bg-white dark:bg-slate-800 border-b border-slate-200 dark:border-slate-700">
                        <div class="flex items-center gap-2 min-w-0">
                            <button @click="sidebarCollapsed = !sidebarCollapsed"
                                class="p-1.5 rounded hover:bg-slate-100 dark:hover:bg-slate-700">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M11 19l-7-7 7-7m8 14l-7-7 7-7" />
                                </svg>
                            </button>
                            <span class="truncate text-sm font-medium w-80 block">{{ selectedFile.name }}</span>
                        </div>

                        <!-- TOC Toggle Button -->
                        <div class="flex items-center gap-1">
                            <button @click="tocCollapsed = !tocCollapsed"
                                class="p-1.5 rounded hover:bg-slate-100 dark:hover:bg-slate-700"
                                :class="{ 'text-blue-500': !tocCollapsed }"
                                title="目录">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M4 6h16M4 12h16M4 18h7" />
                                </svg>
                            </button>
                        </div>

                        <!-- Zoom Controls -->
                        <div class="flex items-center gap-1">
                            <button @click="zoomOut" :disabled="scaleMultiplier <= 0.5"
                                class="p-1.5 rounded hover:bg-slate-100 dark:hover:bg-slate-700 disabled:opacity-50 disabled:cursor-not-allowed"
                                title="缩小 (-)">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M20 12H4" />
                                </svg>
                            </button>
                            <span class="text-sm w-16 text-center">{{ Math.round(scaleMultiplier * 100) }}%</span>
                            <button @click="zoomIn" :disabled="scaleMultiplier >= 2"
                                class="p-1.5 rounded hover:bg-slate-100 dark:hover:bg-slate-700 disabled:opacity-50 disabled:cursor-not-allowed"
                                title="放大 (+)">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M12 4v16m8-8H4" />
                                </svg>
                            </button>
                            <button @click="resetZoom"
                                class="ml-2 px-2 py-1 text-xs rounded hover:bg-slate-100 dark:hover:bg-slate-700"
                                title="重置缩放">
                                {{ fitMode === 'page' ? '适应页面' : '适应宽度' }}
                            </button>
                        </div>

                        <!-- Page Info -->
                        <div class="text-sm text-slate-500 dark:text-slate-400 flex items-center gap-1">
                            <span>第 {{ currentPage }} / {{ totalPages }} 页</span>
                        </div>
                    </div>

                    <!-- PDF Preview Area with TOC -->
                    <div class="flex-1 flex min-w-0 h-[calc(100%-50px)]">
                        <div ref="previewContainer"
                            class="flex-1 min-h-0 overflow-y-auto scrollbar-thin bg-slate-200 dark:bg-slate-950"
                            @scroll="handleScroll">
                            <!-- Empty State -->
                            <div v-if="!selectedFile && !isLoading"
                                class="flex flex-col items-center justify-center h-full p-8">
                                <svg class="w-20 h-20 mb-4 text-slate-300 dark:text-slate-600" fill="none"
                                    stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5"
                                        d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                                </svg>
                                <p class="text-lg font-medium mb-2">欢迎使用 PDF Viewer</p>
                                <p class="text-slate-500 dark:text-slate-400 text-sm">选择一个文件夹 或者 PDF 文件开始浏览</p>

                            </div>

                            <!-- Loading State -->
                            <div v-if="isLoading" class="flex flex-col items-center justify-center h-full">
                                <div
                                    class="animate-spin rounded-full h-12 w-12 border-4 border-slate-200 dark:border-slate-700 border-t-blue-500">
                                </div>
                                <p class="text-slate-500 dark:text-slate-400 mt-4">加载中...</p>
                            </div>

                            <!-- Error State -->
                            <div v-if="error && !isLoading" class="flex flex-col items-center justify-center h-full">
                                <svg class="w-16 h-16 mb-4 text-red-400" fill="none" stroke="currentColor"
                                    viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                                </svg>
                                <p class="font-medium mb-2">加载失败</p>
                                <p class="text-sm text-slate-500 dark:text-slate-400">{{ error }}</p>
                            </div>

                            <!-- PDF Pages -->
                            <div v-if="selectedFile && !isLoading && !error" class="p-4">
                                <div v-for="page in pages" :key="page.num" :data-page="page.num"
                                    class="pdf-page flex justify-center mb-4"
                                    :style="{ minHeight: page.height ? page.height + 'px' : 'auto' }">
                                    <canvas :ref="el => setCanvasRef(page.num, el)"
                                        class="shadow-lg bg-white"
                                        :style="{ width: page.width ? page.width + 'px' : 'auto', height: page.height ? page.height + 'px' : 'auto' }"></canvas>
                                </div>
                            </div>
                        </div>

                        <!-- TOC Sidebar -->
                        <div v-if="selectedFile && !tocCollapsed"
                            class="flex-shrink-0 flex">
                            <div @mousedown="startTocResize"
                                class="w-1 cursor-col-resize hover:bg-blue-400 bg-transparent transition-colors"></div>
                            <aside :style="{ width: tocWidth + 'px' }"
                                class="flex-shrink-0 bg-white dark:bg-slate-800 border-l border-slate-200 dark:border-slate-700 flex flex-col">
                            <div class="p-3 border-b border-slate-200 dark:border-slate-700">
                                <span class="font-semibold text-sm">目录</span>
                            </div>
                            <div class="flex-1 overflow-y-auto p-2">
                                <template v-if="outline.length > 0">
                                    <outline-item v-for="(item, index) in outline" :key="index" :item="item"
                                        :depth="0" @navigate="navigateToOutline" />
                                </template>
                                <div v-else class="text-center text-slate-400 dark:text-slate-500 py-8">
                                    <p class="text-sm">暂无目录</p>
                                </div>
                            </div>
                        </aside>
                        </div>
                    </div>
                </main>
            </div>
        </div>
    </div>

    <!-- Tree Item Component Template -->
    <template id="tree-item-template">
        <div>
            <!-- Folder -->
            <div v-if="item.type === 'folder'"
                class="tree-item flex items-center gap-1 px-2 py-1 rounded cursor-pointer hover:bg-slate-200 dark:hover:bg-slate-700"
                :style="{ paddingLeft: (depth * 12 + 8) + 'px' }" @click="item.expanded = !item.expanded">
                <svg class="w-4 h-4 flex-shrink-0 transition-transform" :class="{ 'rotate-90': item.expanded }"
                    fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                </svg>
                <svg class="w-4 h-4 flex-shrink-0 text-yellow-500" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
                </svg>
                <span class="truncate">{{ item.name }}</span>
            </div>

            <!-- Folder Children -->
            <div v-if="item.type === 'folder' && item.expanded">
                <tree-item v-for="child in item.children" :key="child.path" :item="child" :selected-path="selectedPath"
                    :depth="depth + 1" @select="$emit('select', $event)" />
            </div>

            <!-- File -->
            <div v-if="item.type === 'file'"
                class="tree-item flex items-center gap-1 px-2 py-1 rounded cursor-pointer hover:bg-slate-200 dark:hover:bg-slate-700"
                :class="selectedPath === item.path ? 'bg-blue-100 dark:bg-blue-900' : ''"
                :style="{ paddingLeft: (depth * 12 + 8) + 'px' }" @click="$emit('select', item)">
                <svg class="w-4 h-4 flex-shrink-0 text-red-500" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8l-6-6z" />
                </svg>
                <span class="truncate" :title="item.name">{{ item.name }}</span>
            </div>
        </div>
    </template>

    <!-- Outline Item Template -->
    <template id="outline-item-template">
        <div>
            <!-- Outline with children -->
            <div v-if="item.items && item.items.length > 0"
                class="tree-item flex items-center gap-1 px-2 py-1 rounded cursor-pointer hover:bg-slate-200 dark:hover:bg-slate-700"
                :style="{ paddingLeft: (depth * 12 + 8) + 'px' }" @click="toggleExpand">
                <svg class="w-3 h-3 flex-shrink-0 transition-transform" :class="{ 'rotate-90': isExpanded }"
                    fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                </svg>
                <span class="truncate text-sm">{{ item.title }}</span>
            </div>

            <!-- Outline children -->
            <div v-if="item.items && item.items.length > 0 && isExpanded">
                <outline-item v-for="(child, idx) in item.items" :key="idx" :item="child"
                    :depth="depth + 1" @navigate="$emit('navigate', $event)" />
            </div>

            <!-- Outline without children (clickable) -->
            <div v-if="!item.items || item.items.length === 0"
                class="tree-item flex items-center gap-1 px-2 py-1 rounded cursor-pointer hover:bg-slate-200 dark:hover:bg-slate-700"
                :style="{ paddingLeft: (depth * 12 + 8) + 'px' }" @click="$emit('navigate', item)">
                <span class="w-3 h-3 flex-shrink-0"></span>
                <span class="truncate text-sm">{{ item.title }}</span>
            </div>
        </div>
    </template>

    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.6.347/pdf.min.js"></script>
    <script type="module">
        // Set PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.6.347/pdf.worker.min.js';

        const { createApp, ref, reactive, computed, watch, nextTick, onMounted, onUnmounted } = Vue;

        // Tree Item Component
        const TreeItem = {
            name: 'TreeItem',
            template: '#tree-item-template',
            props: {
                item: Object,
                selectedPath: String,
                depth: { type: Number, default: 0 }
            },
            emits: ['select']
        };

        // Outline Item Component
        const OutlineItem = {
            name: 'OutlineItem',
            template: '#outline-item-template',
            props: {
                item: Object,
                depth: { type: Number, default: 0 }
            },
            emits: ['navigate'],
            setup(props, { emit }) {
                const isExpanded = ref(true);
                const toggleExpand = () => {
                    isExpanded.value = !isExpanded.value;
                };
                return { isExpanded, toggleExpand };
            }
        };

        const app = createApp({
            components: { TreeItem, OutlineItem },

            setup() {
                // 配置常量
                const CONFIG = {
                    // 预加载配置
                    PRELOAD_MARGIN: 200,
                    OBSERVER_THRESHOLD: 0,
                    // 容器内边距
                    CONTAINER_PADDING: 32,
                    // 缩放配置
                    SCALE_MIN: 0.5,
                    SCALE_MAX: 2.0,
                    SCALE_STEP: 0.1,
                    // 防抖延迟
                    SAVE_DEBOUNCE_DELAY: 150,
                    // 长单页判断阈值
                    LONG_PAGE_RATIO: 0.5,
                };

                // 工具函数：创建防抖函数
                const createDebounce = (fn, delay) => {
                    let timeoutId = null;
                    return (...args) => {
                        clearTimeout(timeoutId);
                        timeoutId = setTimeout(() => fn(...args), delay);
                    };
                };

                // 检测是否为 Mac
                const isMac = () => {
                    return navigator.platform.toLowerCase().includes('mac');
                };

                // 获取平台相关的快捷键文本
                const getShortcutText = () => {
                    if (isMac()) {
                        return { folder: '(Cmd+O)', file: '(Cmd+Shift+O)' };
                    }
                    return { folder: '(Ctrl+O)', file: '(Ctrl+Shift+O)' };
                };

                // 触发文件夹选择
                const triggerFolderSelect = () => {
                    const input = document.querySelector('input[type="file"][webkitdirectory]');
                    if (input) input.click();
                };

                // 触发文件选择
                const triggerFileSelect = () => {
                    const input = document.querySelector('input[type="file"][accept=".pdf"]');
                    if (input) input.click();
                };

                // State
                const pdfFiles = ref([]);
                const fileTree = ref([]);
                const selectedFile = ref(null);
                const pages = ref([]);
                const scaleMultiplier = ref(1);
                const currentPage = ref(1);
                const fitMode = ref('width'); // 'width' | 'page'
                const totalPages = ref(0);
                const isDark = ref(false);
                const isLoading = ref(false);
                const error = ref(null);
                const sidebarCollapsed = ref(false);
                const tocCollapsed = ref(true);
                const tocWidth = ref(240);
                let isResizingToc = false;

                const startTocResize = (e) => {
                    isResizingToc = true;
                    document.addEventListener('mousemove', doTocResize);
                    document.addEventListener('mouseup', stopTocResize);
                    e.preventDefault();
                };

                const doTocResize = (e) => {
                    if (!isResizingToc) return;
                    const newWidth = tocWidth.value + e.movementX;
                    if (newWidth >= 150 && newWidth <= 500) {
                        tocWidth.value = newWidth;
                    }
                };

                const stopTocResize = () => {
                    isResizingToc = false;
                    document.removeEventListener('mousemove', doTocResize);
                    document.removeEventListener('mouseup', stopTocResize);
                };

                const outline = ref([]);
                const previewContainer = ref(null);
                const canvasRefs = reactive({});

                let baseScale = 1;
                let currentPdfDoc = null;
                const renderTasks = new Map();
                const renderedPages = new Set(); // 已渲染的页面
                const readingPositionCache = new Map(); // 内存缓存阅读位置
                let intersectionObserver = null;

                // Storage key for reading position
                const getStorageKey = (filePath) => `pdf-reader:${filePath}`;

                // Save reading position
                const saveReadingPosition = () => {
                    if (!selectedFile.value) return;
                    const position = {
                        page: currentPage.value,
                        scrollY: previewContainer.value?.scrollTop || 0
                    };
                    // 同时保存到内存缓存和 localStorage
                    readingPositionCache.set(selectedFile.value.path, position);
                    localStorage.setItem(getStorageKey(selectedFile.value.path), JSON.stringify(position));
                };

                // 防抖保存位置
                const debouncedSavePosition = createDebounce(saveReadingPosition, CONFIG.SAVE_DEBOUNCE_DELAY);

                // Load reading position (优先从内存缓存读取)
                const loadReadingPosition = (filePath) => {
                    // 优先从内存缓存读取（同会话内即时恢复）
                    if (readingPositionCache.has(filePath)) {
                        return readingPositionCache.get(filePath);
                    }
                    // 然后从 localStorage 读取（跨会话恢复）
                    const key = getStorageKey(filePath);
                    const saved = localStorage.getItem(key);
                    return saved ? JSON.parse(saved) : null;
                };

                // Set canvas ref
                const setCanvasRef = (pageNum, el) => {
                    if (el) {
                        canvasRefs[pageNum] = el;
                    }
                };

                // Build file tree from flat FileList
                const buildFileTree = (files) => {
                    const tree = {};
                    const pdfList = [];

                    Array.from(files).forEach(file => {
                        if (!file.name.toLowerCase().endsWith('.pdf')) return;

                        pdfList.push(file);
                        const parts = file.webkitRelativePath.split('/');
                        let current = tree;

                        parts.forEach((part, index) => {
                            if (index === parts.length - 1) {
                                // File
                                if (!current._files) current._files = [];
                                current._files.push({
                                    type: 'file',
                                    name: part,
                                    path: file.webkitRelativePath,
                                    file: file
                                });
                            } else {
                                // Folder
                                if (!current[part]) {
                                    current[part] = { _name: part };
                                }
                                current = current[part];
                            }
                        });
                    });

                    pdfFiles.value = pdfList;

                    // Convert tree object to array
                    const convertToArray = (obj, parentPath = '') => {
                        const result = [];

                        // Add folders
                        Object.keys(obj).filter(k => !k.startsWith('_')).sort().forEach(key => {
                            const path = parentPath ? `${parentPath}/${key}` : key;
                            result.push({
                                type: 'folder',
                                name: key,
                                path: path,
                                expanded: true,
                                children: convertToArray(obj[key], path)
                            });
                        });

                        // Add files
                        if (obj._files) {
                            obj._files.sort((a, b) => a.name.localeCompare(b.name)).forEach(file => {
                                result.push(file);
                            });
                        }

                        return result;
                    };

                    return convertToArray(tree);
                };

                // 通用文件选择处理函数
                const processSelectedFiles = (fileList, isFolder = false) => {
                    const files = Array.from(fileList).filter(f =>
                        f.name.toLowerCase().endsWith('.pdf')
                    );

                    if (files.length === 0) {
                        error.value = '未找到 PDF 文件';
                        return false;
                    }

                    // 构建文件树
                    fileTree.value = isFolder
                        ? buildFileTree(fileList)  // 文件夹模式：保留层次结构
                        : files.map(file => ({    // 文件模式：扁平列表
                            type: 'file',
                            name: file.name,
                            path: file.name,
                            file: file
                        }));

                    // 按名称排序，确保切换顺序和显示顺序一致
                    files.sort((a, b) => a.name.localeCompare(b.name));
                    pdfFiles.value = files;
                    selectedFile.value = null;
                    error.value = null;

                    // 自动选择第一个 PDF
                    const firstFile = files[0];
                    selectFile({
                        type: 'file',
                        name: firstFile.name,
                        path: isFolder ? firstFile.webkitRelativePath : firstFile.name,
                        file: firstFile
                    });

                    return true;
                };

                // Handle folder selection
                const handleFolderSelect = (event) => {
                    const files = event.target.files;
                    if (files && files.length > 0) {
                        processSelectedFiles(files, true);
                    }
                };

                // Handle direct file selection
                const handleFileSelect = (event) => {
                    const files = event.target.files;
                    if (files && files.length > 0) {
                        processSelectedFiles(files, false);
                    }
                };

                // Select file
                const selectFile = async (item) => {
                    if (item.type !== 'file') return;

                    // Save current file's position BEFORE switching
                    if (selectedFile.value) {
                        saveReadingPosition();
                    }
                    
                    selectedFile.value = item;
                    await loadPdf(item.file);
                };

                // Load PDF
                const loadPdf = async (file) => {
                    isLoading.value = true;
                    error.value = null;

                    // 在清空页面前获取保存的阅读位置
                    const savedPosition = loadReadingPosition(selectedFile.value?.path);

                    pages.value = [];
                    outline.value = [];
                    renderedPages.clear();
                    currentPage.value = savedPosition?.page || 1;

                    // Cancel any ongoing render tasks
                    renderTasks.forEach((task) => {
                        task.cancel();
                    });
                    renderTasks.clear();

                    // 断开之前的 observer
                    if (intersectionObserver) {
                        intersectionObserver.disconnect();
                    }

                    // Cleanup previous document
                    if (currentPdfDoc) {
                        currentPdfDoc.destroy();
                        currentPdfDoc = null;
                    }

                    try {
                        const arrayBuffer = await file.arrayBuffer();

                        // 检查文件大小
                        const MAX_FILE_SIZE = 100 * 1024 * 1024; // 100MB
                        if (arrayBuffer.byteLength > MAX_FILE_SIZE) {
                            throw new Error('文件过大，请选择小于 100MB 的 PDF 文件');
                        }

                        const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
                        const pdf = await loadingTask.promise;

                        currentPdfDoc = pdf;
                        totalPages.value = pdf.numPages;

                        // Get outline (table of contents)
                        try {
                            const outlineData = await pdf.getOutline();
                            outline.value = outlineData || [];
                        } catch (e) {
                            console.warn('Failed to get outline:', e);
                            outline.value = [];
                        }

                        // Detect fit mode and calculate base scale
                        fitMode.value = await detectFitMode();
                        baseScale = await calculateBaseScale(1, fitMode.value);

                        // 预计算所有页面尺寸，创建带正确高度的占位符
                        const pagesWithSize = [];
                        for (let i = 1; i <= pdf.numPages; i++) {
                            const page = await pdf.getPage(i);
                            const viewport = page.getViewport({ scale: baseScale * scaleMultiplier.value });
                            pagesWithSize.push({
                                num: i,
                                width: viewport.width,
                                height: viewport.height
                            });
                        }
                        pages.value = pagesWithSize;

                        // Turn off loading FIRST so canvas elements can render
                        isLoading.value = false;

                        // Wait for DOM update
                        await nextTick();

                        // 立即滚动到保存的位置（在渲染之前）
                        if (savedPosition && previewContainer.value) {
                            previewContainer.value.scrollTop = savedPosition.scrollY;
                        }

                        // 设置 Intersection Observer 进行懒加载
                        setupIntersectionObserver();

                        // 强制触发一次可视区域检测，渲染当前可见的页面
                        await renderVisiblePages();

                    } catch (err) {
                        console.error('PDF load error:', err);

                        // 根据错误类型返回友好的错误消息
                        let errorMsg = '无法加载 PDF 文件';
                        if (err.name === 'PasswordException') {
                            errorMsg = '此 PDF 文件已加密，暂不支持';
                        } else if (err.name === 'InvalidPDFException') {
                            errorMsg = '无效的 PDF 文件，请检查文件是否损坏';
                        } else if (err.message && err.message.includes('网络')) {
                            errorMsg = '网络错误，请检查网络连接后重试';
                        } else if (err.message) {
                            errorMsg = err.message;
                        }

                        error.value = errorMsg;
                        isLoading.value = false;
                    }
                };

                // Detect PDF type and determine fit mode
                const detectFitMode = async () => {
                    if (!currentPdfDoc) return 'width';

                    const page = await currentPdfDoc.getPage(1);
                    const viewport = page.getViewport({ scale: 1 });
                    const aspectRatio = viewport.width / viewport.height;

                    // 长单页 PDF：宽高比 < 阈值且只有一页
                    if (aspectRatio < CONFIG.LONG_PAGE_RATIO && currentPdfDoc.numPages === 1) {
                        return 'width';
                    }
                    // 正常分页 PDF
                    return 'page';
                };

                // Calculate scale based on fit mode
                const calculateBaseScale = async (pageNum, mode) => {
                    if (!currentPdfDoc || !previewContainer.value) return 1;

                    const page = await currentPdfDoc.getPage(pageNum);
                    const viewport = page.getViewport({ scale: 1 });
                    const containerWidth = previewContainer.value.clientWidth - CONFIG.CONTAINER_PADDING;
                    const containerHeight = previewContainer.value.clientHeight - CONFIG.CONTAINER_PADDING;

                    if (mode === 'page') {
                        // Fit Page: 取宽度和高度缩放的最小值，确保整页可见
                        const scaleWidth = containerWidth / viewport.width;
                        const scaleHeight = containerHeight / viewport.height;
                        return Math.min(scaleWidth, scaleHeight);
                    } else {
                        // Fit Width: 宽度填满，垂直滚动
                        return (containerWidth / viewport.width) * 0.9;
                    }
                };

                // Setup Intersection Observer for lazy loading
                const setupIntersectionObserver = () => {
                    if (intersectionObserver) {
                        intersectionObserver.disconnect();
                    }

                    intersectionObserver = new IntersectionObserver(
                        (entries) => {
                            entries.forEach(entry => {
                                if (entry.isIntersecting) {
                                    const pageNum = parseInt(entry.target.dataset.page);
                                    if (pageNum && !renderedPages.has(pageNum)) {
                                        renderPage(pageNum);
                                    }
                                }
                            });
                        },
                        {
                            root: previewContainer.value,
                            rootMargin: `${CONFIG.PRELOAD_MARGIN}px 0px`,
                            threshold: CONFIG.OBSERVER_THRESHOLD
                        }
                    );

                    // 观察所有页面容器
                    document.querySelectorAll('.pdf-page').forEach(el => {
                        intersectionObserver.observe(el);
                    });
                };

                // Render only visible pages
                const renderVisiblePages = async () => {
                    const container = previewContainer.value;
                    if (!container) return;

                    const containerRect = container.getBoundingClientRect();
                    const pageElements = document.querySelectorAll('.pdf-page');

                    const renderPromises = [];

                    pageElements.forEach(el => {
                        const rect = el.getBoundingClientRect();
                        const isVisible = rect.bottom > containerRect.top - CONFIG.PRELOAD_MARGIN &&
                                         rect.top < containerRect.bottom + CONFIG.PRELOAD_MARGIN;

                        if (isVisible) {
                            const pageNum = parseInt(el.dataset.page);
                            if (pageNum && !renderedPages.has(pageNum)) {
                                renderPromises.push(renderPage(pageNum));
                            }
                        }
                    });

                    await Promise.all(renderPromises);
                };

                // Render a single page
                const renderPage = async (pageNum) => {
                    if (!currentPdfDoc) return;
                    if (renderedPages.has(pageNum)) return; // 已渲染过则跳过

                    // Cancel any existing render task for this page
                    const existingTask = renderTasks.get(pageNum);
                    if (existingTask) {
                        existingTask.cancel();
                    }

                    const canvas = canvasRefs[pageNum];
                    if (!canvas) return;

                    try {
                        renderedPages.add(pageNum); // 标记为正在渲染
                        
                        const page = await currentPdfDoc.getPage(pageNum);
                        const scale = baseScale * scaleMultiplier.value;
                        const viewport = page.getViewport({ scale });
                        
                        // 获取设备像素比，用于高清渲染
                        const dpr = window.devicePixelRatio || 1;

                        // Canvas 实际像素 = 显示尺寸 × 设备像素比
                        canvas.width = Math.floor(viewport.width * dpr);
                        canvas.height = Math.floor(viewport.height * dpr);
                        
                        // CSS 尺寸保持原样
                        canvas.style.width = `${viewport.width}px`;
                        canvas.style.height = `${viewport.height}px`;

                        const ctx = canvas.getContext('2d');
                        
                        // 缩放绘图上下文以匹配设备像素比
                        ctx.scale(dpr, dpr);

                        const renderTask = page.render({
                            canvasContext: ctx,
                            viewport: viewport
                        });

                        renderTasks.set(pageNum, renderTask);
                        await renderTask.promise;

                    } catch (err) {
                        if (err.message && err.message.includes('cancelled')) {
                            renderedPages.delete(pageNum); // 取消的任务需要移除标记
                            return;
                        }
                        console.error(`Error rendering page ${pageNum}:`, err);
                        renderedPages.delete(pageNum); // 失败的任务需要移除标记
                    } finally {
                        renderTasks.delete(pageNum);
                    }
                };

                // Re-render all pages (for zoom changes)
                const reRenderPages = async () => {
                    renderTasks.forEach((task) => {
                        task.cancel();
                    });
                    renderTasks.clear();
                    renderedPages.clear(); // 清空已渲染标记
                    
                    // 重新计算页面尺寸
                    if (currentPdfDoc) {
                        const pagesWithSize = [];
                        for (let i = 1; i <= currentPdfDoc.numPages; i++) {
                            const page = await currentPdfDoc.getPage(i);
                            const viewport = page.getViewport({ scale: baseScale * scaleMultiplier.value });
                            pagesWithSize.push({
                                num: i,
                                width: viewport.width,
                                height: viewport.height
                            });
                        }
                        pages.value = pagesWithSize;
                        
                        await nextTick();
                        setupIntersectionObserver();
                        await renderVisiblePages();
                    }
                };

                // Handle scroll to update current page and save position
                let scrollRAFId = null;

                const handleScroll = () => {
                    const container = previewContainer.value;
                    if (!container) return;

                    // 使用 requestAnimationFrame 优化性能
                    if (scrollRAFId !== null) {
                        cancelAnimationFrame(scrollRAFId);
                    }

                    scrollRAFId = requestAnimationFrame(() => {
                        const containerRect = container.getBoundingClientRect();
                        const centerY = containerRect.top + containerRect.height / 2;

                        let closestPage = 1;
                        let closestDistance = Infinity;

                        const pageElements = document.querySelectorAll('.pdf-page');

                        for (const el of pageElements) {
                            const rect = el.getBoundingClientRect();
                            const pageCenterY = rect.top + rect.height / 2;
                            const distance = Math.abs(pageCenterY - centerY);

                            if (distance < closestDistance) {
                                closestDistance = distance;
                                closestPage = parseInt(el.dataset.page) || 1;
                            }
                        }

                        currentPage.value = closestPage;
                        scrollRAFId = null;
                    });

                    // 使用防抖保存位置
                    debouncedSavePosition();
                };

                // Zoom controls
                const zoomIn = () => {
                    if (scaleMultiplier.value < CONFIG.SCALE_MAX) {
                        scaleMultiplier.value = Math.min(CONFIG.SCALE_MAX, scaleMultiplier.value + CONFIG.SCALE_STEP);
                        reRenderPages();
                    }
                };

                const zoomOut = () => {
                    if (scaleMultiplier.value > CONFIG.SCALE_MIN) {
                        scaleMultiplier.value = Math.max(CONFIG.SCALE_MIN, scaleMultiplier.value - CONFIG.SCALE_STEP);
                        reRenderPages();
                    }
                };

                const resetZoom = async () => {
                    scaleMultiplier.value = 1;
                    baseScale = await calculateBaseScale(1, fitMode.value);
                    reRenderPages();
                };

                // Keyboard shortcuts
                const handleKeydown = (event) => {
                    // Ignore if typing in input
                    if (event.target.tagName === 'INPUT') return;

                    switch (event.key) {
                        case '+':
                        case '=':
                            event.preventDefault();
                            zoomIn();
                            break;
                        case '-':
                            event.preventDefault();
                            zoomOut();
                            break;
                        case 'o':
                        case 'O':
                            if (event.ctrlKey || event.metaKey) {
                                event.preventDefault();
                                if (event.shiftKey) {
                                    // Ctrl+Shift+O / Cmd+Shift+O: 打开文件
                                    triggerFileSelect();
                                } else {
                                    // Ctrl+O / Cmd+O: 打开文件夹
                                    triggerFolderSelect();
                                }
                            }
                            break;
                        case 'ArrowLeft':
                            if (event.altKey) {
                                event.preventDefault();
                                navigatePrevFile();
                            }
                            break;
                        case 'ArrowRight':
                            if (event.altKey) {
                                event.preventDefault();
                                navigateNextFile();
                            }
                            break;
                    }
                };

                // Navigate to previous/next PDF file
                const navigatePrevFile = () => {
                    if (!selectedFile.value || pdfFiles.value.length === 0) return;
                    const currentIndex = pdfFiles.value.findIndex(f => f.webkitRelativePath === selectedFile.value.path);
                    if (currentIndex > 0) {
                        const prevFile = pdfFiles.value[currentIndex - 1];
                        selectFile({
                            type: 'file',
                            name: prevFile.name,
                            path: prevFile.webkitRelativePath,
                            file: prevFile
                        });
                    }
                };

                const navigateNextFile = () => {
                    if (!selectedFile.value || pdfFiles.value.length === 0) return;
                    const currentIndex = pdfFiles.value.findIndex(f => f.webkitRelativePath === selectedFile.value.path);
                    if (currentIndex < pdfFiles.value.length - 1) {
                        const nextFile = pdfFiles.value[currentIndex + 1];
                        selectFile({
                            type: 'file',
                            name: nextFile.name,
                            path: nextFile.webkitRelativePath,
                            file: nextFile
                        });
                    }
                };

                // Recalculate base scale on window resize
                const handleResize = async () => {
                    if (currentPdfDoc && pages.value.length > 0) {
                        baseScale = await calculateBaseScale(1, fitMode.value);
                        reRenderPages();
                    }
                };

                // Load theme preference
                onMounted(() => {
                    isDark.value = window.matchMedia('(prefers-color-scheme: dark)').matches;
                    window.addEventListener('keydown', handleKeydown);
                    window.addEventListener('resize', handleResize);

                    // 根据平台更新快捷键显示
                    const shortcuts = getShortcutText();
                    const folderShortcutEl = document.getElementById('folder-shortcut');
                    const fileShortcutEl = document.getElementById('file-shortcut');
                    if (folderShortcutEl) folderShortcutEl.textContent = shortcuts.folder;
                    if (fileShortcutEl) fileShortcutEl.textContent = shortcuts.file;
                });

                onUnmounted(() => {
                    saveReadingPosition();

                    // 清理渲染任务
                    renderTasks.forEach((task) => {
                        task.cancel();
                    });
                    renderTasks.clear();

                    // 清理 observer
                    if (intersectionObserver) {
                        intersectionObserver.disconnect();
                        intersectionObserver = null;
                    }

                    // 清理 RAF
                    if (scrollRAFId !== null) {
                        cancelAnimationFrame(scrollRAFId);
                        scrollRAFId = null;
                    }

                    // 清理文档
                    if (currentPdfDoc) {
                        currentPdfDoc.destroy();
                        currentPdfDoc = null;
                    }

                    // 清理事件监听器
                    window.removeEventListener('keydown', handleKeydown);
                    window.removeEventListener('resize', handleResize);
                });

                // Navigate to outline destination
                const navigateToOutline = async (item) => {
                    if (!item.dest && !item.action) return;

                    try {
                        let dest = item.dest;
                        // Handle action (e.g., GoTo action)
                        if (!dest && item.action && item.action.type === 'GoTo') {
                            dest = item.action.dest;
                        }

                        if (!dest) return;

                        let pageNum = 1;

                        // Resolve destination
                        if (typeof dest === 'string') {
                            // Named destination or page reference
                            try {
                                const pageIndex = await currentPdfDoc.getPageIndex(dest);
                                pageNum = pageIndex + 1;
                            } catch (e) {
                                // Try as named destination
                                try {
                                    const destRef = await currentPdfDoc.getDestination(dest);
                                    if (destRef) {
                                        const pageIndex = await currentPdfDoc.getPageIndex(destRef[0]);
                                        pageNum = pageIndex + 1;
                                    }
                                } catch (e2) {
                                    console.warn('Failed to resolve destination:', dest);
                                    return;
                                }
                            }
                        } else if (Array.isArray(dest)) {
                            // Array format: [pageRef, ...]
                            const pageRef = dest[0];
                            // Find page by iterating - avoids Web Worker clone issue
                            for (let i = 1; i <= currentPdfDoc.numPages; i++) {
                                const page = await currentPdfDoc.getPage(i);
                                const ref = page.ref;
                                if (ref && ref.num === pageRef.num && ref.gen === pageRef.gen) {
                                    pageNum = i;
                                    break;
                                }
                            }
                        }

                        // Scroll to the page
                        currentPage.value = pageNum;
                        const pageElement = document.querySelector(`.pdf-page[data-page="${pageNum}"]`);
                        if (pageElement && previewContainer.value) {
                            pageElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                    } catch (e) {
                        console.error('Error navigating to outline:', e);
                    }
                };

                return {
                    pdfFiles,
                    fileTree,
                    selectedFile,
                    pages,
                    scaleMultiplier,
                    currentPage,
                    totalPages,
                    isDark,
                    isLoading,
                    error,
                    sidebarCollapsed,
                    tocCollapsed,
                    tocWidth,
                    startTocResize,
                    outline,
                    previewContainer,
                    setCanvasRef,
                    handleFolderSelect,
                    handleFileSelect,
                    selectFile,
                    fitMode,
                    zoomIn,
                    zoomOut,
                    resetZoom,
                    handleScroll,
                    navigateToOutline
                };
            }
        });

        app.mount('#app');
    </script>
</body>

</html>
